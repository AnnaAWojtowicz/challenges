# LOOPS

# We'll start with the following code:

print('Day 0')  # Day 0
print('Day 1')  # Day 1
print('Day 2')  # Day 2
print('Day 3')  # Day 3
print('Day 4')  # Day 4

# That's a lot of code just to perform nearly the same task five times, right?
# If we were to use a loop, we could make this code much cleaner and shorter.
# Here is the loop version of the code above:

for day in range(5):
	print('Day', day)
	
    # Day 0
    # Day 1
    # Day 2
    # Day 3
    # Day 4
	
# So, how does this work?
# A for loop iterates over a sequence of elements.
# Let's explore the syntax step by step.
# A for loop begins with the keyword "for" followed by a variable representing each item in an iterable. This variable can have any name.

# for item

# Then there's the keyword "in" followed by the sequence to loop over and a colon.

# for item in sequence:

# Finally, there's an indented code block to be executed for each line. The code block has access to the current item of the sequence.

# for item in sequence:
	# Code block to be executed for each item
	# print(item)
	
# The sequence over which the loop iterates can be a list, tuple, string, or a range.
# Here, we loop over a list of fruits:

names = ['apple', 'banana', 'cherry']
for fruit in names:
	print(fruit)

    # apple
    # banana
    # cherry
	

# However, since we don't modify the elements within the list, a tuple would be more suitable.
# Here's the same sequence of elements, but this time we're looping over a tuple:

names = ('apple', 'banana', 'cherry')
for fruit in names:
	print(fruit)

    # apple
    # banana
    # cherry
	
# Here, our sequence is a string. When using a string the loop iterates over each character within the string:

text = 'apple'
for char in text:
	print(char)
	
    # a
    # p
    # p
    # l
    # e   
	
# Finally, a loop can iterate over a range generated by the range() method.
# The range() method is used to generate a sequence of numbers.
# You can define the starting value of the range, the end value, and the step size:
# range(start, stop, step)

# Only a single argument can be passed to range() which will be used as the end value. The range will stop one step before this end value.
# If you do so, the start value defaults to 0, and the step value defaults to 1.

range(3) # creates the range 0, 1, 2
 
range(0,3,1) # same output: 0, 1, 2

# Here, we loop over a range from 2 (included) to 10 (not included) with a step of 2:
for i in range(2,10,2):
	print(i)
	
    # 2
    # 4
    # 6
    # 8
	
# Of course you can do more than just printing the loop variable.
# For example, here we sum all the numbers from 1 to 10:
total = 0
for i in range(1,11):
	total += i
print(total)    # 55


# EXTRA EXAMPLES:

text = '!nuf si gnimmargorp nohtyP'
reversed_text = ''
 
# add code here...
for char in reversed(text):
	reversed_text += char
 
print(reversed_text)
# expected output: 'Python programming is fun!'
 

# LOOPS AND OTHER STUFF:

# Let's consider the following tuple representing your hypothetical yearly income:
# We want to find out when you'll become a millionaire.
# To do so, we'll use a for-loop to iterate through the years and calculate your total income.
# Here's the loop. It notifies us once the total income reaches one million or more:

yearly_income = (250000, 130000, 320000, 320000, 220000, 300000)
total_income = 0
years = 0
 
for income in yearly_income:
   total_income += income
   years += 1
   print(years)
   if total_income >= 1000000:
      print('Millionaire ðŸ’°ðŸ’°ðŸ’°')

# 1
# 2
# 3
# 4
# Millionaire ðŸ’°ðŸ’°ðŸ’°
# 5
# Millionaire ðŸ’°ðŸ’°ðŸ’°
# 6
# Millionaire ðŸ’°ðŸ’°ðŸ’°

# Nice, in year 4 you'll already be a millionaire.
# However, let's pause the excitement for a moment because there's an issue with our code.
# The task of finding your lucky year was completed after the fourth iteration of the loop.
# But it kept iterating through the entire sequence of years. That is pretty inefficient code.
# We need to find a way to stop the loop once our task has been achieved.
# That's where we can use the break statement.
# Let's give it a try. Here, we include a break statement right after the print statement within the if-condition:

yearly_income = (250000, 130000, 320000, 320000, 220000, 300000)
total_income = 0
years = 0
 
for income in yearly_income:
   total_income += income
   years += 1
   print(years)
   if total_income >= 1000000:
      print('Millionaire ðŸ’°ðŸ’°ðŸ’°')
      # terminate loop here
      break
   
# 1
# 2
# 3
# 4
# Millionaire ðŸ’°ðŸ’°ðŸ’°

# Great, now the loop terminates after the condition is fulfilled.
# A break statement can be placed anywhere within the code block of a loop.


# Another statement that you can use to control the flow of a loop is the continue statement.
# continue will cause the loop to directly jump to the next iteration.
# Let's consider the following loop.

for x in 'P#yt#h#on':
   print(x)

#P
##
#y
#t
##
#h
##
#o
#n

# We print each character in the string. But, there are some unwanted # symbols in the string.
# Using continue allows us to skip these unwanted symbols:

for x in 'P#yt#h#on':
   if x == '#':
      continue
   print(x)

#P
#y
#t
#h
#o
#n

# Whenever Python encounters the continue statement, it skips the current iteration and moves on to the next one.
# Thereby, we effectively bypass any code that would have otherwise followed in this iteration.


# EXTRA EXAMPLES:

for i in range(-2,3):
  if i < 0:
    continue
  print(i)

#0
#1
#2


# Sometimes, you are dealing with more complex data than just simple sequences.
# Consider the following representation of a tic tac toe game:

tic_tac_toe = [
  ['X', 'O', 'X'],
  ['O', 'X', 'O'],
  ['O', 'O', 'O']
]

# Here, we have three lists within a list, with each inner list representing a row of the game.
# To access every element within these lists, we need to write nested loops:

tic_tac_toe = [
  ['X', 'O', 'X'],
  ['O', 'X', 'O'],
  ['O', 'O', 'O']
]
for row in tic_tac_toe:
  for item in row:
    print(item)

#X
#O
#X
#O
#X
#O
#O
#O
#O

# What's going on here?
# First, we iterate over each row of the game. And within each iteration, we create another loop in order to iterate over every element within the current row.
# This example might make it a bit more clear:

for x in range(2):
  for y in range(3):
    print('Outer: ', x, 'Inner: ',  y)

#Outer: 0 Inner: 0
#Outer: 0 Inner: 1
#Outer: 0 Inner: 2
#Outer: 1 Inner: 0
#Outer: 1 Inner: 1
#Outer: 1 Inner: 2

# Before the outer loop completes its iteration, it generates an inner loop that iterates over its own entire sequence.
# What about break and continue statements in nested loops?
# You can use the break and continue statements both in inner and outer loops.
# But they will only affect the loop they're used in.
# For example, here the break statement only terminates the inner loop:

for x in range(3):
  for y in range(5):
    if x + y > 2:
      print('Break inner')
      break
    print('Outer: ', x, 'Inner: ',  y)

#Outer: 0 Inner: 0
#Outer: 0 Inner: 1
#Outer: 0 Inner: 2
#Break inner
#Outer: 1 Inner: 0
#Outer: 1 Inner: 1
#Break inner
#Outer: 2 Inner: 0
#Break inner

# Once the inner loop is terminated by the break statement, the outer loop continues and creates a new inner loop in the next iteration.
# 
